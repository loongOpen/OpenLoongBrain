#
# Autogenerated by Thrift Compiler (0.20.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def t_skill_home(self, hand, check_timer):
        """
        Parameters:
         - hand
         - check_timer

        """
        pass

    def t_skill_move(self, x, y, z, rx, ry, rz, hand, check_timer):
        """
        Parameters:
         - x
         - y
         - z
         - rx
         - ry
         - rz
         - hand
         - check_timer

        """
        pass

    def t_skill_move_dir(self, dir_pos, hand, check_timer):
        """
        Parameters:
         - dir_pos
         - hand
         - check_timer

        """
        pass

    def t_skill_move_inc(self, x, y, z, hand, check_timer):
        """
        Parameters:
         - x
         - y
         - z
         - hand
         - check_timer

        """
        pass

    def t_skill_cap_control(self, cap_value, hand):
        """
        Parameters:
         - cap_value
         - hand

        """
        pass

    def t_skill_grasp_bias_set(self, x, y, z, hand):
        """
        Parameters:
         - x
         - y
         - z
         - hand

        """
        pass

    def t_skill_grasp_bias_inc(self, x, y, z, hand):
        """
        Parameters:
         - x
         - y
         - z
         - hand

        """
        pass

    def t_skill_grasp_obj(self, obj_name):
        """
        Parameters:
         - obj_name

        """
        pass

    def t_skill_try_grasp(self, obj_name):
        """
        Parameters:
         - obj_name

        """
        pass

    def t_skill_try_grasp_pass(self, hand):
        """
        Parameters:
         - hand

        """
        pass

    def t_skill_print_word(self, string_):
        """
        Parameters:
         - string_

        """
        pass

    def t_skill_put_with_obj(self, obj_name, x, y, z, hand):
        """
        Parameters:
         - obj_name
         - x
         - y
         - z
         - hand

        """
        pass

    def t_robot_cb(self):
        pass

    def t_enviroment_cb(self):
        pass

    def t_action_grasp_all(self, grasp_max_num):
        """
        Parameters:
         - grasp_max_num

        """
        pass

    def t_action_imitate(self, action_name):
        """
        Parameters:
         - action_name

        """
        pass

    def t_action_safe(self):
        pass

    def t_action_sdk(self):
        pass

    def t_action_grasp_all_beizi(self, grasp_max_num):
        """
        Parameters:
         - grasp_max_num

        """
        pass

    def t_action_grasp_all_mianbao(self, grasp_max_num):
        """
        Parameters:
         - grasp_max_num

        """
        pass

    def t_action_grasp_all_shuiguo(self, grasp_max_num):
        """
        Parameters:
         - grasp_max_num

        """
        pass

    def t_action_grasp_all_zonghe(self, grasp_max_num):
        """
        Parameters:
         - grasp_max_num

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def t_skill_home(self, hand, check_timer):
        """
        Parameters:
         - hand
         - check_timer

        """
        self.send_t_skill_home(hand, check_timer)
        self.recv_t_skill_home()

    def send_t_skill_home(self, hand, check_timer):
        self._oprot.writeMessageBegin('t_skill_home', TMessageType.CALL, self._seqid)
        args = t_skill_home_args()
        args.hand = hand
        args.check_timer = check_timer
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_home(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_home_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_skill_move(self, x, y, z, rx, ry, rz, hand, check_timer):
        """
        Parameters:
         - x
         - y
         - z
         - rx
         - ry
         - rz
         - hand
         - check_timer

        """
        self.send_t_skill_move(x, y, z, rx, ry, rz, hand, check_timer)
        self.recv_t_skill_move()

    def send_t_skill_move(self, x, y, z, rx, ry, rz, hand, check_timer):
        self._oprot.writeMessageBegin('t_skill_move', TMessageType.CALL, self._seqid)
        args = t_skill_move_args()
        args.x = x
        args.y = y
        args.z = z
        args.rx = rx
        args.ry = ry
        args.rz = rz
        args.hand = hand
        args.check_timer = check_timer
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_move(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_move_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_skill_move_dir(self, dir_pos, hand, check_timer):
        """
        Parameters:
         - dir_pos
         - hand
         - check_timer

        """
        self.send_t_skill_move_dir(dir_pos, hand, check_timer)
        self.recv_t_skill_move_dir()

    def send_t_skill_move_dir(self, dir_pos, hand, check_timer):
        self._oprot.writeMessageBegin('t_skill_move_dir', TMessageType.CALL, self._seqid)
        args = t_skill_move_dir_args()
        args.dir_pos = dir_pos
        args.hand = hand
        args.check_timer = check_timer
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_move_dir(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_move_dir_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_skill_move_inc(self, x, y, z, hand, check_timer):
        """
        Parameters:
         - x
         - y
         - z
         - hand
         - check_timer

        """
        self.send_t_skill_move_inc(x, y, z, hand, check_timer)
        self.recv_t_skill_move_inc()

    def send_t_skill_move_inc(self, x, y, z, hand, check_timer):
        self._oprot.writeMessageBegin('t_skill_move_inc', TMessageType.CALL, self._seqid)
        args = t_skill_move_inc_args()
        args.x = x
        args.y = y
        args.z = z
        args.hand = hand
        args.check_timer = check_timer
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_move_inc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_move_inc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_skill_cap_control(self, cap_value, hand):
        """
        Parameters:
         - cap_value
         - hand

        """
        self.send_t_skill_cap_control(cap_value, hand)
        self.recv_t_skill_cap_control()

    def send_t_skill_cap_control(self, cap_value, hand):
        self._oprot.writeMessageBegin('t_skill_cap_control', TMessageType.CALL, self._seqid)
        args = t_skill_cap_control_args()
        args.cap_value = cap_value
        args.hand = hand
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_cap_control(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_cap_control_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_skill_grasp_bias_set(self, x, y, z, hand):
        """
        Parameters:
         - x
         - y
         - z
         - hand

        """
        self.send_t_skill_grasp_bias_set(x, y, z, hand)
        self.recv_t_skill_grasp_bias_set()

    def send_t_skill_grasp_bias_set(self, x, y, z, hand):
        self._oprot.writeMessageBegin('t_skill_grasp_bias_set', TMessageType.CALL, self._seqid)
        args = t_skill_grasp_bias_set_args()
        args.x = x
        args.y = y
        args.z = z
        args.hand = hand
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_grasp_bias_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_grasp_bias_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_skill_grasp_bias_inc(self, x, y, z, hand):
        """
        Parameters:
         - x
         - y
         - z
         - hand

        """
        self.send_t_skill_grasp_bias_inc(x, y, z, hand)
        self.recv_t_skill_grasp_bias_inc()

    def send_t_skill_grasp_bias_inc(self, x, y, z, hand):
        self._oprot.writeMessageBegin('t_skill_grasp_bias_inc', TMessageType.CALL, self._seqid)
        args = t_skill_grasp_bias_inc_args()
        args.x = x
        args.y = y
        args.z = z
        args.hand = hand
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_grasp_bias_inc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_grasp_bias_inc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_skill_grasp_obj(self, obj_name):
        """
        Parameters:
         - obj_name

        """
        self.send_t_skill_grasp_obj(obj_name)
        return self.recv_t_skill_grasp_obj()

    def send_t_skill_grasp_obj(self, obj_name):
        self._oprot.writeMessageBegin('t_skill_grasp_obj', TMessageType.CALL, self._seqid)
        args = t_skill_grasp_obj_args()
        args.obj_name = obj_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_grasp_obj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_grasp_obj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "t_skill_grasp_obj failed: unknown result")

    def t_skill_try_grasp(self, obj_name):
        """
        Parameters:
         - obj_name

        """
        self.send_t_skill_try_grasp(obj_name)
        return self.recv_t_skill_try_grasp()

    def send_t_skill_try_grasp(self, obj_name):
        self._oprot.writeMessageBegin('t_skill_try_grasp', TMessageType.CALL, self._seqid)
        args = t_skill_try_grasp_args()
        args.obj_name = obj_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_try_grasp(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_try_grasp_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "t_skill_try_grasp failed: unknown result")

    def t_skill_try_grasp_pass(self, hand):
        """
        Parameters:
         - hand

        """
        self.send_t_skill_try_grasp_pass(hand)
        self.recv_t_skill_try_grasp_pass()

    def send_t_skill_try_grasp_pass(self, hand):
        self._oprot.writeMessageBegin('t_skill_try_grasp_pass', TMessageType.CALL, self._seqid)
        args = t_skill_try_grasp_pass_args()
        args.hand = hand
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_try_grasp_pass(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_try_grasp_pass_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_skill_print_word(self, string_):
        """
        Parameters:
         - string_

        """
        self.send_t_skill_print_word(string_)
        self.recv_t_skill_print_word()

    def send_t_skill_print_word(self, string_):
        self._oprot.writeMessageBegin('t_skill_print_word', TMessageType.CALL, self._seqid)
        args = t_skill_print_word_args()
        args.string_ = string_
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_print_word(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_print_word_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_skill_put_with_obj(self, obj_name, x, y, z, hand):
        """
        Parameters:
         - obj_name
         - x
         - y
         - z
         - hand

        """
        self.send_t_skill_put_with_obj(obj_name, x, y, z, hand)
        return self.recv_t_skill_put_with_obj()

    def send_t_skill_put_with_obj(self, obj_name, x, y, z, hand):
        self._oprot.writeMessageBegin('t_skill_put_with_obj', TMessageType.CALL, self._seqid)
        args = t_skill_put_with_obj_args()
        args.obj_name = obj_name
        args.x = x
        args.y = y
        args.z = z
        args.hand = hand
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_skill_put_with_obj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_skill_put_with_obj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "t_skill_put_with_obj failed: unknown result")

    def t_robot_cb(self):
        self.send_t_robot_cb()
        return self.recv_t_robot_cb()

    def send_t_robot_cb(self):
        self._oprot.writeMessageBegin('t_robot_cb', TMessageType.CALL, self._seqid)
        args = t_robot_cb_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_robot_cb(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_robot_cb_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "t_robot_cb failed: unknown result")

    def t_enviroment_cb(self):
        self.send_t_enviroment_cb()
        return self.recv_t_enviroment_cb()

    def send_t_enviroment_cb(self):
        self._oprot.writeMessageBegin('t_enviroment_cb', TMessageType.CALL, self._seqid)
        args = t_enviroment_cb_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_enviroment_cb(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_enviroment_cb_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "t_enviroment_cb failed: unknown result")

    def t_action_grasp_all(self, grasp_max_num):
        """
        Parameters:
         - grasp_max_num

        """
        self.send_t_action_grasp_all(grasp_max_num)
        self.recv_t_action_grasp_all()

    def send_t_action_grasp_all(self, grasp_max_num):
        self._oprot.writeMessageBegin('t_action_grasp_all', TMessageType.CALL, self._seqid)
        args = t_action_grasp_all_args()
        args.grasp_max_num = grasp_max_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_action_grasp_all(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_action_grasp_all_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_action_imitate(self, action_name):
        """
        Parameters:
         - action_name

        """
        self.send_t_action_imitate(action_name)
        self.recv_t_action_imitate()

    def send_t_action_imitate(self, action_name):
        self._oprot.writeMessageBegin('t_action_imitate', TMessageType.CALL, self._seqid)
        args = t_action_imitate_args()
        args.action_name = action_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_action_imitate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_action_imitate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_action_safe(self):
        self.send_t_action_safe()
        self.recv_t_action_safe()

    def send_t_action_safe(self):
        self._oprot.writeMessageBegin('t_action_safe', TMessageType.CALL, self._seqid)
        args = t_action_safe_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_action_safe(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_action_safe_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_action_sdk(self):
        self.send_t_action_sdk()
        self.recv_t_action_sdk()

    def send_t_action_sdk(self):
        self._oprot.writeMessageBegin('t_action_sdk', TMessageType.CALL, self._seqid)
        args = t_action_sdk_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_action_sdk(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_action_sdk_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_action_grasp_all_beizi(self, grasp_max_num):
        """
        Parameters:
         - grasp_max_num

        """
        self.send_t_action_grasp_all_beizi(grasp_max_num)
        self.recv_t_action_grasp_all_beizi()

    def send_t_action_grasp_all_beizi(self, grasp_max_num):
        self._oprot.writeMessageBegin('t_action_grasp_all_beizi', TMessageType.CALL, self._seqid)
        args = t_action_grasp_all_beizi_args()
        args.grasp_max_num = grasp_max_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_action_grasp_all_beizi(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_action_grasp_all_beizi_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_action_grasp_all_mianbao(self, grasp_max_num):
        """
        Parameters:
         - grasp_max_num

        """
        self.send_t_action_grasp_all_mianbao(grasp_max_num)
        self.recv_t_action_grasp_all_mianbao()

    def send_t_action_grasp_all_mianbao(self, grasp_max_num):
        self._oprot.writeMessageBegin('t_action_grasp_all_mianbao', TMessageType.CALL, self._seqid)
        args = t_action_grasp_all_mianbao_args()
        args.grasp_max_num = grasp_max_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_action_grasp_all_mianbao(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_action_grasp_all_mianbao_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_action_grasp_all_shuiguo(self, grasp_max_num):
        """
        Parameters:
         - grasp_max_num

        """
        self.send_t_action_grasp_all_shuiguo(grasp_max_num)
        self.recv_t_action_grasp_all_shuiguo()

    def send_t_action_grasp_all_shuiguo(self, grasp_max_num):
        self._oprot.writeMessageBegin('t_action_grasp_all_shuiguo', TMessageType.CALL, self._seqid)
        args = t_action_grasp_all_shuiguo_args()
        args.grasp_max_num = grasp_max_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_action_grasp_all_shuiguo(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_action_grasp_all_shuiguo_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def t_action_grasp_all_zonghe(self, grasp_max_num):
        """
        Parameters:
         - grasp_max_num

        """
        self.send_t_action_grasp_all_zonghe(grasp_max_num)
        self.recv_t_action_grasp_all_zonghe()

    def send_t_action_grasp_all_zonghe(self, grasp_max_num):
        self._oprot.writeMessageBegin('t_action_grasp_all_zonghe', TMessageType.CALL, self._seqid)
        args = t_action_grasp_all_zonghe_args()
        args.grasp_max_num = grasp_max_num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_t_action_grasp_all_zonghe(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = t_action_grasp_all_zonghe_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["t_skill_home"] = Processor.process_t_skill_home
        self._processMap["t_skill_move"] = Processor.process_t_skill_move
        self._processMap["t_skill_move_dir"] = Processor.process_t_skill_move_dir
        self._processMap["t_skill_move_inc"] = Processor.process_t_skill_move_inc
        self._processMap["t_skill_cap_control"] = Processor.process_t_skill_cap_control
        self._processMap["t_skill_grasp_bias_set"] = Processor.process_t_skill_grasp_bias_set
        self._processMap["t_skill_grasp_bias_inc"] = Processor.process_t_skill_grasp_bias_inc
        self._processMap["t_skill_grasp_obj"] = Processor.process_t_skill_grasp_obj
        self._processMap["t_skill_try_grasp"] = Processor.process_t_skill_try_grasp
        self._processMap["t_skill_try_grasp_pass"] = Processor.process_t_skill_try_grasp_pass
        self._processMap["t_skill_print_word"] = Processor.process_t_skill_print_word
        self._processMap["t_skill_put_with_obj"] = Processor.process_t_skill_put_with_obj
        self._processMap["t_robot_cb"] = Processor.process_t_robot_cb
        self._processMap["t_enviroment_cb"] = Processor.process_t_enviroment_cb
        self._processMap["t_action_grasp_all"] = Processor.process_t_action_grasp_all
        self._processMap["t_action_imitate"] = Processor.process_t_action_imitate
        self._processMap["t_action_safe"] = Processor.process_t_action_safe
        self._processMap["t_action_sdk"] = Processor.process_t_action_sdk
        self._processMap["t_action_grasp_all_beizi"] = Processor.process_t_action_grasp_all_beizi
        self._processMap["t_action_grasp_all_mianbao"] = Processor.process_t_action_grasp_all_mianbao
        self._processMap["t_action_grasp_all_shuiguo"] = Processor.process_t_action_grasp_all_shuiguo
        self._processMap["t_action_grasp_all_zonghe"] = Processor.process_t_action_grasp_all_zonghe
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_t_skill_home(self, seqid, iprot, oprot):
        args = t_skill_home_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_home_result()
        try:
            self._handler.t_skill_home(args.hand, args.check_timer)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_home", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_move(self, seqid, iprot, oprot):
        args = t_skill_move_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_move_result()
        try:
            self._handler.t_skill_move(args.x, args.y, args.z, args.rx, args.ry, args.rz, args.hand, args.check_timer)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_move", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_move_dir(self, seqid, iprot, oprot):
        args = t_skill_move_dir_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_move_dir_result()
        try:
            self._handler.t_skill_move_dir(args.dir_pos, args.hand, args.check_timer)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_move_dir", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_move_inc(self, seqid, iprot, oprot):
        args = t_skill_move_inc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_move_inc_result()
        try:
            self._handler.t_skill_move_inc(args.x, args.y, args.z, args.hand, args.check_timer)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_move_inc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_cap_control(self, seqid, iprot, oprot):
        args = t_skill_cap_control_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_cap_control_result()
        try:
            self._handler.t_skill_cap_control(args.cap_value, args.hand)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_cap_control", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_grasp_bias_set(self, seqid, iprot, oprot):
        args = t_skill_grasp_bias_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_grasp_bias_set_result()
        try:
            self._handler.t_skill_grasp_bias_set(args.x, args.y, args.z, args.hand)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_grasp_bias_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_grasp_bias_inc(self, seqid, iprot, oprot):
        args = t_skill_grasp_bias_inc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_grasp_bias_inc_result()
        try:
            self._handler.t_skill_grasp_bias_inc(args.x, args.y, args.z, args.hand)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_grasp_bias_inc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_grasp_obj(self, seqid, iprot, oprot):
        args = t_skill_grasp_obj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_grasp_obj_result()
        try:
            result.success = self._handler.t_skill_grasp_obj(args.obj_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_grasp_obj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_try_grasp(self, seqid, iprot, oprot):
        args = t_skill_try_grasp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_try_grasp_result()
        try:
            result.success = self._handler.t_skill_try_grasp(args.obj_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_try_grasp", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_try_grasp_pass(self, seqid, iprot, oprot):
        args = t_skill_try_grasp_pass_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_try_grasp_pass_result()
        try:
            self._handler.t_skill_try_grasp_pass(args.hand)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_try_grasp_pass", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_print_word(self, seqid, iprot, oprot):
        args = t_skill_print_word_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_print_word_result()
        try:
            self._handler.t_skill_print_word(args.string_)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_print_word", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_skill_put_with_obj(self, seqid, iprot, oprot):
        args = t_skill_put_with_obj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_skill_put_with_obj_result()
        try:
            result.success = self._handler.t_skill_put_with_obj(args.obj_name, args.x, args.y, args.z, args.hand)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_skill_put_with_obj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_robot_cb(self, seqid, iprot, oprot):
        args = t_robot_cb_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_robot_cb_result()
        try:
            result.success = self._handler.t_robot_cb()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_robot_cb", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_enviroment_cb(self, seqid, iprot, oprot):
        args = t_enviroment_cb_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_enviroment_cb_result()
        try:
            result.success = self._handler.t_enviroment_cb()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_enviroment_cb", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_action_grasp_all(self, seqid, iprot, oprot):
        args = t_action_grasp_all_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_action_grasp_all_result()
        try:
            self._handler.t_action_grasp_all(args.grasp_max_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_action_grasp_all", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_action_imitate(self, seqid, iprot, oprot):
        args = t_action_imitate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_action_imitate_result()
        try:
            self._handler.t_action_imitate(args.action_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_action_imitate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_action_safe(self, seqid, iprot, oprot):
        args = t_action_safe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_action_safe_result()
        try:
            self._handler.t_action_safe()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_action_safe", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_action_sdk(self, seqid, iprot, oprot):
        args = t_action_sdk_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_action_sdk_result()
        try:
            self._handler.t_action_sdk()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_action_sdk", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_action_grasp_all_beizi(self, seqid, iprot, oprot):
        args = t_action_grasp_all_beizi_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_action_grasp_all_beizi_result()
        try:
            self._handler.t_action_grasp_all_beizi(args.grasp_max_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_action_grasp_all_beizi", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_action_grasp_all_mianbao(self, seqid, iprot, oprot):
        args = t_action_grasp_all_mianbao_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_action_grasp_all_mianbao_result()
        try:
            self._handler.t_action_grasp_all_mianbao(args.grasp_max_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_action_grasp_all_mianbao", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_action_grasp_all_shuiguo(self, seqid, iprot, oprot):
        args = t_action_grasp_all_shuiguo_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_action_grasp_all_shuiguo_result()
        try:
            self._handler.t_action_grasp_all_shuiguo(args.grasp_max_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_action_grasp_all_shuiguo", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_t_action_grasp_all_zonghe(self, seqid, iprot, oprot):
        args = t_action_grasp_all_zonghe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = t_action_grasp_all_zonghe_result()
        try:
            self._handler.t_action_grasp_all_zonghe(args.grasp_max_num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("t_action_grasp_all_zonghe", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class t_skill_home_args(object):
    """
    Attributes:
     - hand
     - check_timer

    """


    def __init__(self, hand=None, check_timer=None,):
        self.hand = hand
        self.check_timer = check_timer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.hand = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.check_timer = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_home_args')
        if self.hand is not None:
            oprot.writeFieldBegin('hand', TType.I32, 1)
            oprot.writeI32(self.hand)
            oprot.writeFieldEnd()
        if self.check_timer is not None:
            oprot.writeFieldBegin('check_timer', TType.DOUBLE, 2)
            oprot.writeDouble(self.check_timer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_home_args)
t_skill_home_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'hand', None, None, ),  # 1
    (2, TType.DOUBLE, 'check_timer', None, None, ),  # 2
)


class t_skill_home_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_home_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_home_result)
t_skill_home_result.thrift_spec = (
)


class t_skill_move_args(object):
    """
    Attributes:
     - x
     - y
     - z
     - rx
     - ry
     - rz
     - hand
     - check_timer

    """


    def __init__(self, x=None, y=None, z=None, rx=None, ry=None, rz=None, hand=None, check_timer=None,):
        self.x = x
        self.y = y
        self.z = z
        self.rx = rx
        self.ry = ry
        self.rz = rz
        self.hand = hand
        self.check_timer = check_timer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.rx = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.ry = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.rz = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.hand = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.check_timer = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_move_args')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        if self.rx is not None:
            oprot.writeFieldBegin('rx', TType.DOUBLE, 4)
            oprot.writeDouble(self.rx)
            oprot.writeFieldEnd()
        if self.ry is not None:
            oprot.writeFieldBegin('ry', TType.DOUBLE, 5)
            oprot.writeDouble(self.ry)
            oprot.writeFieldEnd()
        if self.rz is not None:
            oprot.writeFieldBegin('rz', TType.DOUBLE, 6)
            oprot.writeDouble(self.rz)
            oprot.writeFieldEnd()
        if self.hand is not None:
            oprot.writeFieldBegin('hand', TType.I32, 7)
            oprot.writeI32(self.hand)
            oprot.writeFieldEnd()
        if self.check_timer is not None:
            oprot.writeFieldBegin('check_timer', TType.DOUBLE, 8)
            oprot.writeDouble(self.check_timer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_move_args)
t_skill_move_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
    (4, TType.DOUBLE, 'rx', None, None, ),  # 4
    (5, TType.DOUBLE, 'ry', None, None, ),  # 5
    (6, TType.DOUBLE, 'rz', None, None, ),  # 6
    (7, TType.I32, 'hand', None, None, ),  # 7
    (8, TType.DOUBLE, 'check_timer', None, None, ),  # 8
)


class t_skill_move_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_move_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_move_result)
t_skill_move_result.thrift_spec = (
)


class t_skill_move_dir_args(object):
    """
    Attributes:
     - dir_pos
     - hand
     - check_timer

    """


    def __init__(self, dir_pos=None, hand=None, check_timer=None,):
        self.dir_pos = dir_pos
        self.hand = hand
        self.check_timer = check_timer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dir_pos = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.hand = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.check_timer = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_move_dir_args')
        if self.dir_pos is not None:
            oprot.writeFieldBegin('dir_pos', TType.STRING, 1)
            oprot.writeString(self.dir_pos.encode('utf-8') if sys.version_info[0] == 2 else self.dir_pos)
            oprot.writeFieldEnd()
        if self.hand is not None:
            oprot.writeFieldBegin('hand', TType.I32, 2)
            oprot.writeI32(self.hand)
            oprot.writeFieldEnd()
        if self.check_timer is not None:
            oprot.writeFieldBegin('check_timer', TType.DOUBLE, 5)
            oprot.writeDouble(self.check_timer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_move_dir_args)
t_skill_move_dir_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'dir_pos', 'UTF8', None, ),  # 1
    (2, TType.I32, 'hand', None, None, ),  # 2
    None,  # 3
    None,  # 4
    (5, TType.DOUBLE, 'check_timer', None, None, ),  # 5
)


class t_skill_move_dir_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_move_dir_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_move_dir_result)
t_skill_move_dir_result.thrift_spec = (
)


class t_skill_move_inc_args(object):
    """
    Attributes:
     - x
     - y
     - z
     - hand
     - check_timer

    """


    def __init__(self, x=None, y=None, z=None, hand=None, check_timer=None,):
        self.x = x
        self.y = y
        self.z = z
        self.hand = hand
        self.check_timer = check_timer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.hand = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.check_timer = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_move_inc_args')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        if self.hand is not None:
            oprot.writeFieldBegin('hand', TType.I32, 4)
            oprot.writeI32(self.hand)
            oprot.writeFieldEnd()
        if self.check_timer is not None:
            oprot.writeFieldBegin('check_timer', TType.DOUBLE, 5)
            oprot.writeDouble(self.check_timer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_move_inc_args)
t_skill_move_inc_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
    (4, TType.I32, 'hand', None, None, ),  # 4
    (5, TType.DOUBLE, 'check_timer', None, None, ),  # 5
)


class t_skill_move_inc_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_move_inc_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_move_inc_result)
t_skill_move_inc_result.thrift_spec = (
)


class t_skill_cap_control_args(object):
    """
    Attributes:
     - cap_value
     - hand

    """


    def __init__(self, cap_value=None, hand=None,):
        self.cap_value = cap_value
        self.hand = hand

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.cap_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.hand = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_cap_control_args')
        if self.cap_value is not None:
            oprot.writeFieldBegin('cap_value', TType.DOUBLE, 1)
            oprot.writeDouble(self.cap_value)
            oprot.writeFieldEnd()
        if self.hand is not None:
            oprot.writeFieldBegin('hand', TType.I32, 2)
            oprot.writeI32(self.hand)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_cap_control_args)
t_skill_cap_control_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'cap_value', None, None, ),  # 1
    (2, TType.I32, 'hand', None, None, ),  # 2
)


class t_skill_cap_control_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_cap_control_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_cap_control_result)
t_skill_cap_control_result.thrift_spec = (
)


class t_skill_grasp_bias_set_args(object):
    """
    Attributes:
     - x
     - y
     - z
     - hand

    """


    def __init__(self, x=None, y=None, z=None, hand=None,):
        self.x = x
        self.y = y
        self.z = z
        self.hand = hand

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.hand = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_grasp_bias_set_args')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        if self.hand is not None:
            oprot.writeFieldBegin('hand', TType.I32, 4)
            oprot.writeI32(self.hand)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_grasp_bias_set_args)
t_skill_grasp_bias_set_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
    (4, TType.I32, 'hand', None, None, ),  # 4
)


class t_skill_grasp_bias_set_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_grasp_bias_set_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_grasp_bias_set_result)
t_skill_grasp_bias_set_result.thrift_spec = (
)


class t_skill_grasp_bias_inc_args(object):
    """
    Attributes:
     - x
     - y
     - z
     - hand

    """


    def __init__(self, x=None, y=None, z=None, hand=None,):
        self.x = x
        self.y = y
        self.z = z
        self.hand = hand

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.hand = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_grasp_bias_inc_args')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 3)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        if self.hand is not None:
            oprot.writeFieldBegin('hand', TType.I32, 4)
            oprot.writeI32(self.hand)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_grasp_bias_inc_args)
t_skill_grasp_bias_inc_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
    (3, TType.DOUBLE, 'z', None, None, ),  # 3
    (4, TType.I32, 'hand', None, None, ),  # 4
)


class t_skill_grasp_bias_inc_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_grasp_bias_inc_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_grasp_bias_inc_result)
t_skill_grasp_bias_inc_result.thrift_spec = (
)


class t_skill_grasp_obj_args(object):
    """
    Attributes:
     - obj_name

    """


    def __init__(self, obj_name=None,):
        self.obj_name = obj_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.obj_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_grasp_obj_args')
        if self.obj_name is not None:
            oprot.writeFieldBegin('obj_name', TType.STRING, 1)
            oprot.writeString(self.obj_name.encode('utf-8') if sys.version_info[0] == 2 else self.obj_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_grasp_obj_args)
t_skill_grasp_obj_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'obj_name', 'UTF8', None, ),  # 1
)


class t_skill_grasp_obj_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_grasp_obj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_grasp_obj_result)
t_skill_grasp_obj_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class t_skill_try_grasp_args(object):
    """
    Attributes:
     - obj_name

    """


    def __init__(self, obj_name=None,):
        self.obj_name = obj_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.obj_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_try_grasp_args')
        if self.obj_name is not None:
            oprot.writeFieldBegin('obj_name', TType.STRING, 1)
            oprot.writeString(self.obj_name.encode('utf-8') if sys.version_info[0] == 2 else self.obj_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_try_grasp_args)
t_skill_try_grasp_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'obj_name', 'UTF8', None, ),  # 1
)


class t_skill_try_grasp_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_try_grasp_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_try_grasp_result)
t_skill_try_grasp_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class t_skill_try_grasp_pass_args(object):
    """
    Attributes:
     - hand

    """


    def __init__(self, hand=None,):
        self.hand = hand

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.hand = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_try_grasp_pass_args')
        if self.hand is not None:
            oprot.writeFieldBegin('hand', TType.I32, 1)
            oprot.writeI32(self.hand)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_try_grasp_pass_args)
t_skill_try_grasp_pass_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'hand', None, None, ),  # 1
)


class t_skill_try_grasp_pass_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_try_grasp_pass_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_try_grasp_pass_result)
t_skill_try_grasp_pass_result.thrift_spec = (
)


class t_skill_print_word_args(object):
    """
    Attributes:
     - string_

    """


    def __init__(self, string_=None,):
        self.string_ = string_

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.string_ = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_print_word_args')
        if self.string_ is not None:
            oprot.writeFieldBegin('string_', TType.STRING, 1)
            oprot.writeString(self.string_.encode('utf-8') if sys.version_info[0] == 2 else self.string_)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_print_word_args)
t_skill_print_word_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'string_', 'UTF8', None, ),  # 1
)


class t_skill_print_word_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_print_word_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_print_word_result)
t_skill_print_word_result.thrift_spec = (
)


class t_skill_put_with_obj_args(object):
    """
    Attributes:
     - obj_name
     - x
     - y
     - z
     - hand

    """


    def __init__(self, obj_name=None, x=None, y=None, z=None, hand=None,):
        self.obj_name = obj_name
        self.x = x
        self.y = y
        self.z = z
        self.hand = hand

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.obj_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.z = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.hand = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_put_with_obj_args')
        if self.obj_name is not None:
            oprot.writeFieldBegin('obj_name', TType.STRING, 1)
            oprot.writeString(self.obj_name.encode('utf-8') if sys.version_info[0] == 2 else self.obj_name)
            oprot.writeFieldEnd()
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 2)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 3)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        if self.z is not None:
            oprot.writeFieldBegin('z', TType.DOUBLE, 4)
            oprot.writeDouble(self.z)
            oprot.writeFieldEnd()
        if self.hand is not None:
            oprot.writeFieldBegin('hand', TType.I32, 5)
            oprot.writeI32(self.hand)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_put_with_obj_args)
t_skill_put_with_obj_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'obj_name', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'x', None, None, ),  # 2
    (3, TType.DOUBLE, 'y', None, None, ),  # 3
    (4, TType.DOUBLE, 'z', None, None, ),  # 4
    (5, TType.I32, 'hand', None, None, ),  # 5
)


class t_skill_put_with_obj_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_skill_put_with_obj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_skill_put_with_obj_result)
t_skill_put_with_obj_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class t_robot_cb_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_robot_cb_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_robot_cb_args)
t_robot_cb_args.thrift_spec = (
)


class t_robot_cb_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Robot()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_robot_cb_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_robot_cb_result)
t_robot_cb_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Robot, None], None, ),  # 0
)


class t_enviroment_cb_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_enviroment_cb_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_enviroment_cb_args)
t_enviroment_cb_args.thrift_spec = (
)


class t_enviroment_cb_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Env()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_enviroment_cb_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_enviroment_cb_result)
t_enviroment_cb_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Env, None], None, ),  # 0
)


class t_action_grasp_all_args(object):
    """
    Attributes:
     - grasp_max_num

    """


    def __init__(self, grasp_max_num=None,):
        self.grasp_max_num = grasp_max_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.grasp_max_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_grasp_all_args')
        if self.grasp_max_num is not None:
            oprot.writeFieldBegin('grasp_max_num', TType.I32, 1)
            oprot.writeI32(self.grasp_max_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_grasp_all_args)
t_action_grasp_all_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'grasp_max_num', None, None, ),  # 1
)


class t_action_grasp_all_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_grasp_all_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_grasp_all_result)
t_action_grasp_all_result.thrift_spec = (
)


class t_action_imitate_args(object):
    """
    Attributes:
     - action_name

    """


    def __init__(self, action_name=None,):
        self.action_name = action_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.action_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_imitate_args')
        if self.action_name is not None:
            oprot.writeFieldBegin('action_name', TType.STRING, 1)
            oprot.writeString(self.action_name.encode('utf-8') if sys.version_info[0] == 2 else self.action_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_imitate_args)
t_action_imitate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'action_name', 'UTF8', None, ),  # 1
)


class t_action_imitate_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_imitate_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_imitate_result)
t_action_imitate_result.thrift_spec = (
)


class t_action_safe_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_safe_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_safe_args)
t_action_safe_args.thrift_spec = (
)


class t_action_safe_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_safe_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_safe_result)
t_action_safe_result.thrift_spec = (
)


class t_action_sdk_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_sdk_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_sdk_args)
t_action_sdk_args.thrift_spec = (
)


class t_action_sdk_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_sdk_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_sdk_result)
t_action_sdk_result.thrift_spec = (
)


class t_action_grasp_all_beizi_args(object):
    """
    Attributes:
     - grasp_max_num

    """


    def __init__(self, grasp_max_num=None,):
        self.grasp_max_num = grasp_max_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.grasp_max_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_grasp_all_beizi_args')
        if self.grasp_max_num is not None:
            oprot.writeFieldBegin('grasp_max_num', TType.I32, 1)
            oprot.writeI32(self.grasp_max_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_grasp_all_beizi_args)
t_action_grasp_all_beizi_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'grasp_max_num', None, None, ),  # 1
)


class t_action_grasp_all_beizi_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_grasp_all_beizi_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_grasp_all_beizi_result)
t_action_grasp_all_beizi_result.thrift_spec = (
)


class t_action_grasp_all_mianbao_args(object):
    """
    Attributes:
     - grasp_max_num

    """


    def __init__(self, grasp_max_num=None,):
        self.grasp_max_num = grasp_max_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.grasp_max_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_grasp_all_mianbao_args')
        if self.grasp_max_num is not None:
            oprot.writeFieldBegin('grasp_max_num', TType.I32, 1)
            oprot.writeI32(self.grasp_max_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_grasp_all_mianbao_args)
t_action_grasp_all_mianbao_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'grasp_max_num', None, None, ),  # 1
)


class t_action_grasp_all_mianbao_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_grasp_all_mianbao_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_grasp_all_mianbao_result)
t_action_grasp_all_mianbao_result.thrift_spec = (
)


class t_action_grasp_all_shuiguo_args(object):
    """
    Attributes:
     - grasp_max_num

    """


    def __init__(self, grasp_max_num=None,):
        self.grasp_max_num = grasp_max_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.grasp_max_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_grasp_all_shuiguo_args')
        if self.grasp_max_num is not None:
            oprot.writeFieldBegin('grasp_max_num', TType.I32, 1)
            oprot.writeI32(self.grasp_max_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_grasp_all_shuiguo_args)
t_action_grasp_all_shuiguo_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'grasp_max_num', None, None, ),  # 1
)


class t_action_grasp_all_shuiguo_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_grasp_all_shuiguo_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_grasp_all_shuiguo_result)
t_action_grasp_all_shuiguo_result.thrift_spec = (
)


class t_action_grasp_all_zonghe_args(object):
    """
    Attributes:
     - grasp_max_num

    """


    def __init__(self, grasp_max_num=None,):
        self.grasp_max_num = grasp_max_num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.grasp_max_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_grasp_all_zonghe_args')
        if self.grasp_max_num is not None:
            oprot.writeFieldBegin('grasp_max_num', TType.I32, 1)
            oprot.writeI32(self.grasp_max_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_grasp_all_zonghe_args)
t_action_grasp_all_zonghe_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'grasp_max_num', None, None, ),  # 1
)


class t_action_grasp_all_zonghe_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('t_action_grasp_all_zonghe_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(t_action_grasp_all_zonghe_result)
t_action_grasp_all_zonghe_result.thrift_spec = (
)
fix_spec(all_structs)
del all_structs
